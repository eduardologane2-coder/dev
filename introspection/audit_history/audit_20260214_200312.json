{
  "timestamp": "20260214_200312",
  "structural_report": {
    "total_python_files": 76,
    "entrypoints": [
      "/srv/dev/dev_bot.py",
      "/srv/dev/gatekeeper.py"
    ],
    "execution_points": [
      "/srv/dev/tests/test_selfmod_integrity.py",
      "/srv/dev/executor.py",
      "/srv/dev/tests/test_validator.py"
    ],
    "subprocess_users": [
      "executor",
      "test_validator",
      "test_selfmod_integrity"
    ],
    "duplicate_candidates": [],
    "layer_classification": {
      "long_term_handler": "UNKNOWN_LAYER",
      "dev_executor": "EXECUTION_LAYER",
      "context_lock_engine": "CORE_ENGINE",
      "briefing_history_engine": "CORE_ENGINE",
      "metacognition_engine": "CORE_ENGINE",
      "plan_executor": "EXECUTION_LAYER",
      "alignment_contract": "UNKNOWN_LAYER",
      "gatekeeper": "GOVERNANCE_LAYER",
      "architecture_governance": "GOVERNANCE_LAYER",
      "selfmod_engine": "CORE_ENGINE",
      "dev_bot": "UNKNOWN_LAYER",
      "test_semantic_memory": "TEST_LAYER",
      "joseph_status_handler": "UNKNOWN_LAYER",
      "dominant_intent_engine": "CORE_ENGINE",
      "architecture_audit": "UNKNOWN_LAYER",
      "cognitive_validator": "UNKNOWN_LAYER",
      "evolution_engine": "CORE_ENGINE",
      "selfmod_policy": "UNKNOWN_LAYER",
      "plan_validator": "UNKNOWN_LAYER",
      "test_metacognition": "TEST_LAYER",
      "selfmod_integrity": "UNKNOWN_LAYER",
      "architecture_state": "UNKNOWN_LAYER",
      "task_engine": "CORE_ENGINE",
      "cognitive_log_engine": "CORE_ENGINE",
      "mode_engine": "CORE_ENGINE",
      "strategy_engine": "CORE_ENGINE",
      "confidence_gate": "GOVERNANCE_LAYER",
      "context_lock": "UNKNOWN_LAYER",
      "joseph_contract": "UNKNOWN_LAYER",
      "semantic_memory_engine": "CORE_ENGINE",
      "_metrics_patch": "UNKNOWN_LAYER",
      "selfmod_validator": "UNKNOWN_LAYER",
      "intention_engine": "CORE_ENGINE",
      "metrics_engine": "CORE_ENGINE",
      "versioning": "UNKNOWN_LAYER",
      "strategy_llm_engine": "CORE_ENGINE",
      "cognitive_engine": "CORE_ENGINE",
      "test_joseph_integration": "TEST_LAYER",
      "human_renderer": "UNKNOWN_LAYER",
      "alignment_handler": "UNKNOWN_LAYER",
      "evolution_transition_engine": "CORE_ENGINE",
      "llm_planner": "UNKNOWN_LAYER",
      "architecture_version": "UNKNOWN_LAYER",
      "impact_engine": "CORE_ENGINE",
      "maturity_engine": "CORE_ENGINE",
      "plan_engine": "CORE_ENGINE",
      "briefing_engine": "CORE_ENGINE",
      "context_shift_engine": "CORE_ENGINE",
      "post_commit_engine": "CORE_ENGINE",
      "git_auto_commit": "UNKNOWN_LAYER",
      "cognitive_score_engine": "CORE_ENGINE",
      "metrics_handler": "UNKNOWN_LAYER",
      "metrics_report_handler": "UNKNOWN_LAYER",
      "long_term_engine": "CORE_ENGINE",
      "phase_engine": "CORE_ENGINE",
      "llm_engine": "CORE_ENGINE",
      "alignment_engine": "CORE_ENGINE",
      "decision_engine": "CORE_ENGINE",
      "_main_patch": "UNKNOWN_LAYER",
      "joseph_sync": "UNKNOWN_LAYER",
      "prioritizer_engine": "CORE_ENGINE",
      "confidence_engine": "CORE_ENGINE",
      "strategy_core": "STRATEGY_LAYER",
      "executor": "EXECUTION_LAYER",
      "cognitive_metrics_handler": "UNKNOWN_LAYER",
      "conflict_engine": "CORE_ENGINE",
      "cognitive_metrics_engine": "CORE_ENGINE",
      "test_phase_engine": "CORE_ENGINE",
      "test_evolution_transition": "TEST_LAYER",
      "test_validator": "TEST_LAYER",
      "test_integrity": "TEST_LAYER",
      "test_mode_engine": "CORE_ENGINE",
      "__init__": "UNKNOWN_LAYER",
      "test_selfmod_integrity": "TEST_LAYER",
      "test_prioritizer": "TEST_LAYER",
      "test_conflict": "TEST_LAYER"
    },
    "import_graph_size": 68
  },
  "llm_analysis": "## 1) Leitura estrutural (o que o relatório já prova)\n\n- **76 arquivos Python** com **2 entrypoints** (`dev_bot.py`, `gatekeeper.py`) e **múltiplos pontos de execução** adicionais (`executor.py` e testes que executam subprocessos).\n- **Import graph size 68**: praticamente o sistema inteiro está no mesmo “grafo de acoplamento” (pouca segmentação real).\n- A classificação de camadas mostra um **núcleo grande (CORE_ENGINE)** e muitas peças críticas marcadas como **UNKNOWN_LAYER** (ou seja: a arquitetura “real” não está codificada/expressa no layout e nas dependências).\n- **Testes usando subprocesso** (`executor`, `test_validator`, `test_selfmod_integrity`): isso é um sinal forte de que o sistema depende de efeitos colaterais/estado global/execução como processo para isolar comportamento — normalmente sintoma de acoplamento e falta de fronteiras.\n\n---\n\n## 2) Riscos arquiteturais reais (não teóricos)\n\n### R1) Fronteiras de camada não são verificáveis (UNKNOWN_LAYER demais)\nComponentes que deveriam ser claramente “bordas” ou “contratos” aparecem como UNKNOWN:\n- `dev_bot`, `alignment_contract`, `plan_validator`, `selfmod_policy`, `selfmod_validator`, `cognitive_validator`, `architecture_state/version`, `git_auto_commit`, `human_renderer`, `metrics_handler/report_handler`, `context_lock`, `long_term_handler`, etc.\n\n**Risco real:** qualquer um desses pode estar importando CORE_ENGINE diretamente e virando “atalho” para o núcleo. Isso cria:\n- dependências circulares implícitas,\n- impossibilidade de trocar implementação sem quebrar metade do grafo,\n- testes que precisam subir o sistema inteiro.\n\n**Sinal no relatório:** import_graph_size alto + muitos UNKNOWN em itens que parecem “interfaces/handlers”.\n\n---\n\n### R2) Mistura de camadas: Governança/Execução/Core provavelmente se cruzam\nVocê tem uma camada de **GOVERNANCE_LAYER** (`gatekeeper`, `architecture_governance`, `confidence_gate`) e uma de **EXECUTION_LAYER** (`executor`, `plan_executor`, `dev_executor`), mas:\n- `gatekeeper.py` é entrypoint: tende a “orquestrar tudo”.\n- `executor.py` também é ponto de execução e é usado via subprocesso por testes.\n\n**Risco real:** governança chamando execução que chama core que chama governança (ou core chamando governança diretamente). Isso mata previsibilidade e torna validações “opcionais” (bypass por import direto).\n\n**Sinal no relatório:** governança e execução são pontos de entrada/execução, e há “validators/policies” fora de camada.\n\n---\n\n### R3) Auto-modificação + git auto commit dentro do mesmo grafo de importação\nPresença de:\n- `selfmod_engine`, `selfmod_integrity`, `selfmod_policy`, `selfmod_validator`\n- `git_auto_commit`, `post_commit_engine`, `versioning`, `architecture_version/state`\n\n**Risco real:** o mesmo runtime que decide/valida pode também alterar e commitar código. Se as dependências não forem estritamente unidirecionais, você cria:\n- caminho de execução onde **validação pode ser pulada**,\n- risco de “commit de estado inválido” por falha parcial,\n- testes que precisam rodar em subprocesso para não “sujar” o processo atual.\n\n**Sinal no relatório:** testes de integridade e validator executam subprocessos; isso costuma ser para conter efeitos colaterais (filesystem/git).\n\n---\n\n### R4) “Engines” demais sem fronteira explícita → acoplamento por convenção\nHá muitos CORE_ENGINE: `cognitive_engine`, `llm_engine`, `strategy_engine`, `plan_engine`, `task_engine`, `phase_engine`, `mode_engine`, `impact_engine`, `maturity_engine`, `confidence_engine`, `conflict_engine`, `semantic_memory_engine`, etc.\n\n**Risco real:** sem uma API/contrato explícito, “engine” vira “importa e chama”. Isso:\n- aumenta fan-in/fan-out,\n- cria dependência de ordem de inicialização,\n- incentiva estado global compartilhado (mesmo que não apareça no relatório, é o padrão que leva a subprocesso em testes).\n\n**Sinal no relatório:** import_graph_size alto e ausência de módulos “interfaces/adapters” claramente separados.\n\n---\n\n### R5) Testes classificados como CORE_ENGINE (anomalia)\n`test_phase_engine` e `test_mode_engine` aparecem como CORE_ENGINE, não TEST_LAYER.\n\n**Risco real:** ou a classificação está errada, ou os testes estão dentro do pacote principal/importados pelo runtime. Em ambos os casos:\n- risco de testes vazarem para produção,\n- risco de dependências de teste contaminarem o grafo principal,\n- risco de side effects em import.\n\n---\n\n## 3) Acoplamentos perigosos (prováveis, com base nos sinais)\n\nSem ver o código eu não afirmo “A importa B”, mas o relatório indica **pontos de acoplamento estrutural**:\n\n1) **Entrypoints (dev_bot/gatekeeper) como “god objects”**\n   - Se eles importam muitos engines diretamente, viram o hub do grafo.\n   - Isso impede execução parcial e dificulta isolar features.\n\n2) **Validators/Policies fora de GOVERNANCE_LAYER**\n   - `plan_validator`, `selfmod_validator`, `cognitive_validator`, `alignment_contract/handler/engine` em UNKNOWN.\n   - Isso sugere validação espalhada e potencialmente bypassável.\n\n3) **Git/Versioning dentro do runtime cognitivo**\n   - `git_auto_commit`, `post_commit_engine`, `versioning` fora de uma borda clara.\n   - Isso tende a puxar filesystem/subprocess para dentro do core.\n\n4) **Handlers/Renderers/Sync como UNKNOWN**\n   - `human_renderer`, `metrics_*_handler`, `joseph_sync/status_handler`\n   - Tipicamente são adaptadores I/O; se importam core e também são importados pelo core, vira ciclo.\n\n---\n\n## 4) Mistura de camadas (onde está mais provável)\n\n- **CORE_ENGINE ↔ GOVERNANCE_LAYER**: `confidence_gate` vs `confidence_engine`. Se o engine chama o gate, ou o gate chama engine e engine chama gate, você tem governança “dentro” do core.\n- **CORE_ENGINE ↔ EXECUTION_LAYER**: `plan_executor/dev_executor/executor` provavelmente chamam engines, mas se engines chamam executor para “rodar plano”, inverte a dependência.\n- **CORE_ENGINE ↔ I/O (git, renderer, sync, metrics handlers)**: tudo que é handler/sync/commit deveria ser borda; como está UNKNOWN, é provável que esteja misturado.\n\n---\n\n## 5) Maturidade arquitetural (0–10)\n\n**Nota: 5.5 / 10**\n\nJustificativa objetiva:\n- (+) Existe intenção de camadas (CORE/GOVERNANCE/EXECUTION/STRATEGY/TEST).\n- (+) Núcleo parece modularizado em engines (melhor que monólito único).\n- (–) Muitos componentes críticos sem camada definida (UNKNOWN) → fronteiras não são aplicáveis.\n- (–) Import graph grande → acoplamento transversal.\n- (–) Subprocesso em testes para isolar execução → indica side effects e/ou estado global.\n- (–) Auto-modificação + git + validação no mesmo grafo → risco operacional alto se não houver barreiras rígidas.\n\n---\n\n## 6) Evolução mínima (sem revolução, sem “criar módulos” sem substituir algo)\n\n### E1) Tornar “UNKNOWN_LAYER” uma dívida rastreável e reduzir em 2–3 passos\n**Ação mínima:** reclassificar e ajustar dependências de **apenas os itens mais perigosos**:\n- Mover conceitualmente (não necessariamente fisicamente) para “bordas”:\n  - `git_auto_commit`, `human_renderer`, `metrics_handler`, `metrics_report_handler`, `joseph_sync`\n- E para governança:\n  - `plan_validator`, `selfmod_policy`, `selfmod_validator`, `cognitive_validator`, `alignment_contract`\n\n**Critério de aceite:** CORE_ENGINE não importa esses itens; apenas entrypoints/execution/governance importam.\n\nIsso não cria módulo novo; é **realinhar dependências** e, se necessário, renomear/realocar arquivos existentes.\n\n---\n\n### E2) Regra de dependência unidirecional (aplicação mínima)\nDefinir e aplicar (via teste simples de import) uma regra:\n\n- `CORE_ENGINE` **não pode importar** `EXECUTION_LAYER`, `GOVERNANCE_LAYER`, handlers I/O (renderer/git/sync/metrics handlers).\n- `GOVERNANCE_LAYER` pode importar CORE_ENGINE.\n- `EXECUTION_LAYER` pode importar CORE_ENGINE e GOVERNANCE_LAYER (se necessário), mas não o inverso.\n- `TEST_LAYER` pode importar tudo, mas nada importa TEST_LAYER.\n\n**Por que isso é mínimo:** é só uma regra + um teste de verificação do grafo (você já tem auditoria e testes de integridade; encaixa no que existe).\n\n---\n\n### E3) Conter efeitos colaterais: “subprocess” como último recurso, não como padrão\nHoje subprocess aparece em `executor` e testes de validator/integrity.\n\n**Ação mínima:** identificar 1–2 pontos de side effect (provavelmente git/commit e execução externa) e:\n- encapsular chamadas de subprocess em funções únicas,\n- permitir “modo dry-run”/mock via injeção simples (parâmetro de função), sem framework novo.\n\n**Critério de aceite:** testes principais não precisam subir subprocesso para validar lógica pura (deixe subprocess só para testes de integração).\n\n---\n\n### E4) Separar “contrato” de “implementação” onde já existe nome de contrato\nVocê já tem `alignment_contract` e `joseph_contract`.\n\n**Ação mínima:** garantir que:\n- contratos não importem engines,\n- engines implementem contratos (ou pelo menos dependam de tipos/estruturas do contrato, não do handler).\n\nIsso reduz acoplamento sem criar módulo novo — é ajustar imports e responsabilidades.\n\n---\n\n### E5) Corrigir anomalia: testes aparecendo como CORE_ENGINE\n`test_phase_engine`, `test_mode_engine` classificados como CORE_ENGINE.\n\n**Ação mínima:** garantir que:\n- arquivos de teste não estejam no pacote importável de runtime,\n- não sejam importados por `__init__` ou por engines.\n\n**Critério de aceite:** qualquer import de `test_*` falha no runtime (ou simplesmente não existe no path de produção).\n\n---\n\n## 7) Checklist de verificação (objetivo, rápido)\n\n1) Existe algum import de `git_auto_commit` dentro de CORE_ENGINE? Se sim, risco alto.\n2) `selfmod_engine` chama `git_auto_commit` diretamente? Se sim, bypass de governança provável.\n3) `plan_engine` importa `plan_executor`? Se sim, inversão de dependência.\n4) Algum `engine` importa `gatekeeper`/`confidence_gate`? Se sim, governança vazou para core.\n5) Algum módulo de produção importa `test_*`? Se sim, contaminação.\n6) Quantos UNKNOWN são I/O (renderer/sync/handlers)? Se muitos, borda está misturada.\n\n---\n\nSe você me der o **grafo de imports por arquivo** (ou só os imports dos entrypoints e dos módulos `selfmod_*`, `git_auto_commit`, `gatekeeper`, `executor`), eu consigo apontar **acoplamentos concretos (A→B)** e dizer exatamente onde a regra de dependência está sendo violada."
}